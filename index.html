<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8"/>
<title>Simplex KKT - Interativo Funcional (correções)</title>
<style>
  body { font-family: Arial, Helvetica, sans-serif; padding:18px; background:#f6f9fc; color:#0b2545; }
  h1{margin-bottom:6px;}
  .card{background:#fff;padding:12px;border-radius:8px;box-shadow:0 6px 18px rgba(11,37,69,0.06);margin-bottom:12px}
  label{display:inline-block;margin-right:10px}
  input[type=number], input[type=text], select{width:95px;padding:6px;border:1px solid #cbd5e1;border-radius:6px}
  input.incorrect{border-color:#dc2626;background:#fee2e2}
  button{padding:8px 12px;border-radius:6px;border:none;background:#2563eb;color:#fff;cursor:pointer;margin-right:6px}
  button.ghost{background:#64748b}
  table{border-collapse:collapse;margin-top:8px;width:100%}
  th,td{border:1px solid #e2e8f0;padding:6px;text-align:center;font-size:13px}
  caption{font-weight:bold;margin-bottom:6px;text-align:left}
  .status{margin-top:10px;padding:8px;border-radius:6px}
  .ok{background:#ecfccb;color:#14532d}
  .err{background:#fee2e2;color:#7f1d1d}
  .prevTable input{background:#f3f4f6;border-color:#e2e8f0}
  .note{font-size:13px;color:#334155;margin-top:8px}
  #finalScore{font-weight:bold;margin-top:12px}
  .pane{background:#fff;padding:12px;border-radius:8px;box-shadow:0 6px 18px rgba(11,37,69,0.06);margin-bottom:12px}
  .small{font-size:13px;color:#334155}
  .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:8px}
  .table-counter { font-size:13px; margin-bottom:8px; color:#334155; }
</style>
</head>
<body>

<h1>Simplex KKT - Quadrático Interativo</h1>

<div class="pane">
  <div class="small"><strong>Instruções rápidas</strong></div>
  <ol class="small">
    <li>Preencha o Formulário com o seu nome.</li>
    <li>Escolha número de variáveis (n) e número de restrições (m) e clique em <em>Gerar Formulário</em>.</li>
    <li>Preencha os coeficientes (função objetivo quadrática: termos quadráticos, cruzados e lineares; e as m restrições). Clique em <em>Iniciar Iterações</em>.</li>
    <li>No modo exercício, o aluno deverá preencher o próximo tableau usando como referência o tableau anterior e clicar em <em>Verificar Iteração</em>. O tableau atual aparece em branco — o aluno deve digitar todas as células.</li>
    <li>Várias tentativas são permitidas; somente a primeira vez que cada célula for acertada ela conta para a nota.</li>
    <li>Ao final de todas iterações, clique em <em>Gerar PDF</em> para gerar o Relatório de Desempenho do Aluno (inclui os tableaus preenchidos).</li>
  </ol>
  <hr />
</div>

<div class="card">
  <label>Nome do aluno: <input id="studentName" type="text" placeholder="Digite seu nome"></label>
  <div style="margin-top:10px">
    <label>n (variáveis): <input id="input_n" type="number" min="1" value="2"></label>
    <label>m (restrições): <input id="input_m" type="number" min="1" value="1"></label>
    <button id="genForm" class="ghost">Gerar Formulário</button>
  </div>

  <div id="dynamicForm" style="margin-top:12px"></div>

  <div class="note">Observação: as restrições <b>xᵢ ≥ 0</b> são implícitas.</div>
  
  <div style="margin-top:12px">
    <button id="start">Iniciar Iterações</button>
    <button id="restart" class="ghost" style="display:none">Reiniciar</button>
  </div>
</div>

<div id="iterationsArea" class="card" style="display:none"></div>
<div id="feedback" class="status" style="display:none"></div>
<div id="finalScore"></div>
<div style="margin-top:12px">
  <button id="generatePDF" style="display:none">Gerar PDF</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script>
// ----------------- util -----------------
function numFrom(id,fallback=0){ const el=document.getElementById(id); if(!el) return fallback; const v=parseFloat(el.value); return Number.isFinite(v)?v:fallback; }
function fmt(x){ return (Math.abs(x) < 1e-12) ? '0' : Number(x).toFixed(6); }

// ----------------- globais -----------------
let n = 2, m = 1;
let varNames = [];            // array de nomes como ['x1','x2','x3'...]
let base = [];                // base atual (strings)
let A = [], b = [], autoIterations = []; // autoIterations = [{base,A,b,pivot}]
let currentIter = 0;
let studentName = '';
let totalCells = 0;           // total de células que devem ser acertadas (base + A + b por iteração)
let correctCellsSet = new Set(); // guarda chaves "idx_r_col" para não contar 2x o mesmo acerto
let correctCount = 0;

// gera nomes: x1..xn (originais), folgas x{n+1}..x{n+m}, y1..yn, y{n+1}..y{n+m}
function buildVarNames(n,m){
  const names=[];
  for(let i=1;i<=n;i++) names.push('x'+i);
  for(let k=1;k<=m;k++) names.push('x'+(n+k)); // folgas como x_{n+1}...
  for(let i=1;i<=n;i++) names.push('y'+i);
  for(let k=1;k<=m;k++) names.push('y'+(n+k));
  return names;
}

// ----------------- FORM DINÂMICO -----------------
function generateForm(){
  n = Math.max(1, Math.floor(numFrom('input_n',2)));
  m = Math.max(1, Math.floor(numFrom('input_m',1)));
  const container = document.getElementById('dynamicForm');
  container.innerHTML = '';

  // Função objetivo card
  const foCard = document.createElement('div'); foCard.className = 'card';
  foCard.innerHTML = `<div class="small"><strong>Função objetivo (maximizar) — termos quadráticos e lineares</strong></div>`;
  const grid = document.createElement('div'); grid.className = 'grid';

  for(let i=1;i<=n;i++){
    const id = `c_x${i}sq`;
    const div = document.createElement('div');
    div.innerHTML = `<label>coef x${i}²: <input id="${id}" type="number" step="any" value="-1"></label>`;
    grid.appendChild(div);
  }
  for(let i=1;i<=n;i++){
    for(let j=i+1;j<=n;j++){
      const id = `c_x${i}x${j}`;
      const div = document.createElement('div');
      div.innerHTML = `<label>coef x${i}x${j}: <input id="${id}" type="number" step="any" value="0"></label>`;
      grid.appendChild(div);
    }
  }
  for(let i=1;i<=n;i++){
    const id = `c_x${i}`;
    const div = document.createElement('div');
    div.innerHTML = `<label>coef x${i}: <input id="${id}" type="number" step="any" value="6"></label>`;
    grid.appendChild(div);
  }
  foCard.appendChild(grid);
  container.appendChild(foCard);

  // restrições card
  const restrCard = document.createElement('div'); restrCard.className = 'card';
  restrCard.innerHTML = `<div class="small"><strong>Restrições lineares (≤)</strong></div>`;
  const tbl = document.createElement('table');
  let thead = `<tr><th>Restrição</th>`;
  for(let j=1;j<=n;j++) thead += `<th>a${j}</th>`;
  thead += `<th>b</th></tr>`;
  tbl.innerHTML = thead;
  for(let k=1;k<=m;k++){
    const tr = document.createElement('tr');
    let rowHtml = `<td>r${k}</td>`;
    for(let j=1;j<=n;j++){
      rowHtml += `<td><input id="a_${k}_${j}" type="number" step="any" value="${(j===k?1: (j===1 && k===1?2:0))}"></td>`;
    }
    rowHtml += `<td><input id="b_${k}" type="number" step="any" value="${(k===1?8:0)}"></td>`;
    tr.innerHTML = rowHtml;
    tbl.appendChild(tr);
  }
  restrCard.appendChild(tbl);
  container.appendChild(restrCard);

  const note = document.createElement('div'); note.className = 'note';
  note.innerHTML = 'Observação: as restrições xᵢ ≥ 0 são implícitas.';
  container.appendChild(note);
}

// ----------------- MONTAR KKT (A,b) -----------------
function montarProblema(){
  // lê coeficientes FO
  const c_x = new Array(n+1).fill(0);
  const c_x_sq = new Array(n+1).fill(0);
  const c_cross = {};
  for(let i=1;i<=n;i++){
    c_x[i] = numFrom(`c_x${i}`,0);
    c_x_sq[i] = numFrom(`c_x${i}sq`,0);
  }
  for(let i=1;i<=n;i++){
    for(let j=i+1;j<=n;j++){
      c_cross[`${i}_${j}`] = numFrom(`c_x${i}x${j}`,0);
    }
  }

  // lê restrições
  const a = Array.from({length: m+1}, ()=> new Array(n+1).fill(0));
  const bvec = new Array(m+1).fill(0);
  for(let k=1;k<=m;k++){
    for(let j=1;j<=n;j++) a[k][j] = numFrom(`a_${k}_${j}`,0);
    bvec[k] = numFrom(`b_${k}`,0);
  }

  // varNames e base
  varNames = buildVarNames(n,m);
  base = [];
  for(let k=1;k<=m;k++) base.push('x'+(n+k)); // folgas
  for(let i=1;i<=n;i++) base.push('y'+i);

  // dims
  const rows = n + m;
  const cols = 2*(n + m);
  A = Array.from({length: rows}, ()=> new Array(cols).fill(0));
  b = new Array(rows).fill(0);

  const off_x = 0;
  const off_s = n;
  const off_y1 = n + m;
  const off_y2 = n + m + n;

  // linhas das restrições
  for(let k=1;k<=m;k++){
    const r = k-1;
    for(let j=1;j<=n;j++) A[r][off_x + (j-1)] = a[k][j];
    A[r][off_s + (k-1)] = 1;
    b[r] = bvec[k];
  }

  // linhas de estacionaridade
  for(let i=1;i<=n;i++){
    const r = m + (i-1);
    for(let j=1;j<=n;j++){
      if(i===j) A[r][off_x + (j-1)] = 2 * c_x_sq[i];
      else {
        const key = (i<j) ? `${i}_${j}` : `${j}_${i}`;
        A[r][off_x + (j-1)] = c_cross[key] || 0;
      }
    }
    A[r][off_y1 + (i-1)] = 1;
    for(let k=1;k<=m;k++) A[r][off_y2 + (k-1)] = -a[k][i];
    b[r] = -c_x[i];
  }

  return {A,b};
}

// ----------------- salvar iteração -----------------
function saveAutoIteration(pivotInfo=null){
  // copia defensiva
  autoIterations.push({
    base: base.slice(),
    A: A.map(r => r.slice()),
    b: b.slice(),
    pivot: pivotInfo
  });
}

// ----------------- pivot, enteringVar, solveAutomatic -----------------
function pivot(row,col){
  const pv = A[row][col]; if(Math.abs(pv) < 1e-12) return;
  for(let j=0;j<A[row].length;j++) A[row][j] /= pv;
  b[row] /= pv;
  for(let i=0;i<A.length;i++){
    if(i===row) continue;
    const factor = A[i][col];
    for(let j=0;j<A[i].length;j++) A[i][j] -= factor * A[row][j];
    b[i] -= factor * b[row];
  }
  base[row] = varNames[col];
  saveAutoIteration({row: row, col: col});
}

function enteringVar(){
  let minVal = 0, row = -1;
  for(let i=0;i<b.length;i++){
    if(b[i] < minVal){ minVal = b[i]; row = i; }
  }
  if(row === -1) return null;
  const leaveVar = base[row];
  const enterVar = leaveVar.startsWith('x') ? 'y'+leaveVar.slice(1) : 'x'+leaveVar.slice(1);
  const col = varNames.indexOf(enterVar);
  return { row, col };
}

function isOptimal(){ return b.every(v => v >= -1e-9); }

function solveAutomatic(){
  montarProblema();
  // reset autoIterations e salvar estado inicial
  autoIterations = [];
  saveAutoIteration(null);
  let safety = 0;
  while(!isOptimal() && safety < 200){
    const pv = enteringVar();
    if(!pv || pv.col < 0) break;
    pivot(pv.row, pv.col);
    safety++;
  }
  // calcula totalCells (base + A entries + b) por iteração (exceto iteração 0? incluímos todas)
  totalCells = 0;
  for(let idx = 0; idx < autoIterations.length; idx++){
    const it = autoIterations[idx];
    const rows = it.base.length;
    const cols = it.A[0].length;
    // por linha: 1 (base) + cols (A) + 1 (b)
    totalCells += rows * (1 + cols + 1);
  }
  // reset contadores de acertos
  correctCellsSet.clear();
  correctCount = 0;
}

// ----------------- renderização das iterações -----------------
function renderStudentIteration(idx){
  const area = document.getElementById('iterationsArea');
  area.style.display = 'block';
  area.innerHTML = '';

  if(autoIterations.length === 0){
    area.innerHTML = '<div class="note">Não há iterações (gere o formulário e inicie).</div>';
    return;
  }

  if(idx < 0) idx = 0;
  if(idx >= autoIterations.length){
    area.innerHTML = '<div class="note">Todas as iterações já foram mostradas.</div>';
    return;
  }

  // mostra índice/contador
  const counter = document.createElement('div');
  counter.className = 'table-counter';
  counter.innerText = `Iteração ${idx+1} de ${autoIterations.length}`;
  area.appendChild(counter);

  // mostra referência anterior — somente se houver (idx>0)
  if(idx > 0){
    const prev = autoIterations[idx-1];
    const tblPrev = document.createElement('table');
    tblPrev.className = 'prevTable';
    tblPrev.innerHTML = `<caption>Iteração ${idx} (anterior - referência)</caption>`;
    const trh = document.createElement('tr');
    trh.innerHTML = '<th>Base</th>' + varNames.map(v=>`<th>${v}</th>`).join('') + '<th>b</th>';
    tblPrev.appendChild(trh);
    for(let r=0;r<prev.base.length;r++){
      const tr = document.createElement('tr');
      let rowHtml = `<td><input type="text" value="${prev.base[r]}" readonly></td>`;
      for(let j=0;j<varNames.length;j++) rowHtml += `<td><input type="text" value="${fmt(prev.A[r][j])}" readonly></td>`;
      rowHtml += `<td><input type="text" value="${fmt(prev.b[r])}" readonly></td>`;
      tr.innerHTML = rowHtml;
      tblPrev.appendChild(tr);
    }
    area.appendChild(tblPrev);
  }

  // tabela atual — EM BRANCO para o aluno preencher (toda a tabela)
  const curr = autoIterations[idx];
  const tbl = document.createElement('table');
  tbl.innerHTML = `<caption>Iteração ${idx+1} (preencha TODOS os campos abaixo)</caption>`;
  const trh2 = document.createElement('tr');
  trh2.innerHTML = '<th>Base</th>' + varNames.map(v=>`<th>${v}</th>`).join('') + '<th>b</th>';
  tbl.appendChild(trh2);

  for(let r=0;r<curr.base.length;r++){
    const tr = document.createElement('tr');
    let rowHtml = `<td><input id="iter_${idx}_base_${r}" type="text" value=""></td>`;
    for(let j=0;j<varNames.length;j++){
      rowHtml += `<td><input id="iter_${idx}_cell_${r}_${j}" type="text" value=""></td>`;
    }
    rowHtml += `<td><input id="iter_${idx}_b_${r}" type="text" value=""></td>`;
    tr.innerHTML = rowHtml;
    tbl.appendChild(tr);
  }
  area.appendChild(tbl);

  const note = document.createElement('div'); note.className = 'note';
  note.innerText = 'Preencha toda a tabela atual (base, todas as colunas, b). Use a iteração anterior como referência (se disponível).';
  area.appendChild(note);

  const btn = document.createElement('button'); btn.innerText = 'Verificar Iteração';
  btn.onclick = () => checkIteration(idx);
  area.appendChild(btn);

  document.getElementById('restart').style.display = 'inline-block';
}

// ----------------- verificação (com contagem por célula) -----------------
function checkIteration(idx){
  if(idx < 0 || idx >= autoIterations.length) return;
  const it = autoIterations[idx];
  let allCorrect = true;

  // percorre cada célula da iteração atual
  for(let r=0;r<it.base.length;r++){
    // base string
    const baseEl = document.getElementById(`iter_${idx}_base_${r}`);
    const baseVal = baseEl && baseEl.value ? baseEl.value.trim() : '';
    baseEl.classList.remove('incorrect');
    const keyBase = `${idx}_base_${r}`;
    if(baseVal === it.base[r]){
      if(!correctCellsSet.has(keyBase)){ correctCellsSet.add(keyBase); correctCount++; }
    } else {
      allCorrect = false;
      baseEl.classList.add('incorrect');
    }

    // cols A
    for(let j=0;j<varNames.length;j++){
      const el = document.getElementById(`iter_${idx}_cell_${r}_${j}`);
      const raw = el && el.value ? el.value.trim() : '';
      el.classList.remove('incorrect');
      let val = NaN;
      if(raw.includes('/')){ const p = raw.split('/'); val = parseFloat(p[0]) / parseFloat(p[1]); }
      else val = parseFloat(raw.replace(',', '.'));
      const keyCell = `${idx}_cell_${r}_${j}`;
      if(Number.isFinite(val) && Math.abs(val - it.A[r][j]) <= 1e-4){
        if(!correctCellsSet.has(keyCell)){ correctCellsSet.add(keyCell); correctCount++; }
      } else {
        allCorrect = false;
        el.classList.add('incorrect');
      }
    }

    // b
    const bEl = document.getElementById(`iter_${idx}_b_${r}`);
    const rawb = bEl && bEl.value ? bEl.value.trim() : '';
    bEl.classList.remove('incorrect');
    let bv = NaN;
    if(rawb.includes('/')){ const p = rawb.split('/'); bv = parseFloat(p[0]) / parseFloat(p[1]); }
    else bv = parseFloat(rawb.replace(',', '.'));
    const keyB = `${idx}_b_${r}`;
    if(Number.isFinite(bv) && Math.abs(bv - it.b[r]) <= 1e-4){
      if(!correctCellsSet.has(keyB)){ correctCellsSet.add(keyB); correctCount++; }
    } else {
      allCorrect = false;
      bEl.classList.add('incorrect');
    }
  }

  // mostra feedback
  const fb = document.getElementById('feedback');
  fb.style.display = 'block';
  if(allCorrect){
    fb.className = 'status ok';
    fb.innerText = '✅ Iteração correta!';
    // Avança para próxima
    currentIter++;
    if(currentIter < autoIterations.length){
      renderStudentIteration(currentIter);
    } else {
      // fim: calcula nota
      const nota = totalCells ? Math.round(100 * correctCount / totalCells) : 0;
      fb.innerText = `✅ Todas as iterações preenchidas. Nota final: ${nota}/100`;
      document.getElementById('finalScore').innerText = `Nota final: ${nota}/100`;
      document.getElementById('generatePDF').style.display = 'inline-block';
    }
  } else {
    fb.className = 'status err';
    // mostra percentual parcial (opcional)
    const notaParcial = totalCells ? Math.round(100 * correctCount / totalCells) : 0;
    fb.innerText = `❌ Existem erros — revise as células em vermelho. Progresso atual: ${notaParcial}/100 (não finalize).`;
  }
}

// ----------------- PDF (inclui tableaus preenchidos pelo aluno) -----------------
function generatePDF(){
  const { jsPDF } = window.jspdf;
  const doc = new jsPDF({unit:'pt'});
  doc.setFontSize(14);
  doc.text('Relatório de Desempenho - Simplex KKT', 40, 40);
  doc.setFontSize(11);
  doc.text(`Aluno: ${studentName}`, 40, 68);
  const nota = totalCells ? Math.round(100 * correctCount / totalCells) : 0;
  doc.text(`Nota final: ${nota}/100`, 40, 88);
  doc.text(`Células corretas: ${correctCount} de ${totalCells}`, 40, 106);

  let y = 130;
  // para cada iteração, desenha a tabela baseada no que o aluno digitou (ou vazio)
  autoIterations.forEach((it, idx) => {
    doc.setFontSize(12);
    doc.text(`Iteração ${idx+1}`, 40, y); y += 16;
    const cols = varNames.length + 2; // base + vars + b
    // header
    doc.setFontSize(10);
    let header = 'Base\t' + varNames.join('\t') + '\tb';
    // divisão simplificada: escrever em linhas de texto com tabs
    doc.text(header, 50, y); y += 14;
    for(let r=0;r<it.base.length;r++){
      const baseVal = (document.getElementById(`iter_${idx}_base_${r}`) && document.getElementById(`iter_${idx}_base_${r}`).value) || '';
      let line = baseVal;
      for(let j=0;j<varNames.length;j++){
        const el = document.getElementById(`iter_${idx}_cell_${r}_${j}`);
        line += '\t' + ((el && el.value) ? el.value : '');
      }
      const bel = document.getElementById(`iter_${idx}_b_${r}`);
      line += '\t' + ((bel && bel.value) ? bel.value : '');
      // quebra de página simples
      if(y > 700){ doc.addPage(); y = 40; }
      doc.text(line, 50, y);
      y += 14;
    }
    y += 8;
    if(y > 700){ doc.addPage(); y = 40; }
  });

  doc.save(`${studentName.replace(/\s+/g,'_')}_SimplexKKT_report.pdf`);
}

// ----------------- eventos -----------------
document.getElementById('genForm').addEventListener('click', ()=>{
  // limpar estados (quando gerar novo formulário)
  autoIterations = []; A = []; b = []; base = []; currentIter = 0;
  correctCellsSet.clear(); correctCount = 0; totalCells = 0;
  document.getElementById('iterationsArea').innerHTML = '';
  document.getElementById('feedback').style.display = 'none';
  document.getElementById('finalScore').innerText = '';
  document.getElementById('generatePDF').style.display = 'none';
  generateForm();
});

document.getElementById('start').addEventListener('click', ()=>{
  studentName = document.getElementById('studentName').value.trim() || 'Aluno(a) não informado(a)';
  solveAutomatic();
  // start from iteration 0 (aluno preenche a iteração 0 — estado inicial)
  currentIter = 0;
  document.getElementById('feedback').style.display = 'none';
  document.getElementById('finalScore').innerText = '';
  document.getElementById('generatePDF').style.display = 'none';
  renderStudentIteration(currentIter);
});

document.getElementById('restart').addEventListener('click', ()=>{
  autoIterations=[]; A=[]; b=[]; base=[]; currentIter=0;
  correctCellsSet.clear(); correctCount = 0; totalCells = 0;
  document.getElementById('iterationsArea').innerHTML = '';
  document.getElementById('feedback').style.display='none';
  document.getElementById('finalScore').innerText='';
  document.getElementById('restart').style.display='none';
  document.getElementById('generatePDF').style.display='none';
});

document.getElementById('generatePDF').addEventListener('click', generatePDF);

// inicializa
generateForm();
</script>
</body>
</html>
