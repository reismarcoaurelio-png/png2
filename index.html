<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8"/>
<title>Simplex KKT - Interativo Funcional (corrigido)</title>
<style>
  body { font-family: Arial, Helvetica, sans-serif; padding:18px; background:#f6f9fc; color:#0b2545; }
  h1{margin-bottom:6px;}
  .card{background:#fff;padding:12px;border-radius:8px;box-shadow:0 6px 18px rgba(11,37,69,0.06);margin-bottom:12px}
  label{display:inline-block;margin-right:10px}
  input[type=number], input[type=text], select{width:95px;padding:6px;border:1px solid #cbd5e1;border-radius:6px}
  input.incorrect{border-color:#dc2626;background:#fee2e2}
  button{padding:8px 12px;border-radius:6px;border:none;background:#2563eb;color:#fff;cursor:pointer;margin-right:6px}
  button.ghost{background:#64748b}
  table{border-collapse:collapse;margin-top:8px;width:100%}
  th,td{border:1px solid #e2e8f0;padding:6px;text-align:center;font-size:13px}
  caption{font-weight:bold;margin-bottom:6px;text-align:left}
  .status{margin-top:10px;padding:8px;border-radius:6px}
  .ok{background:#ecfccb;color:#14532d}
  .err{background:#fee2e2;color:#7f1d1d}
  .prevTable input{background:#f3f4f6;border-color:#e2e8f0}
  .note{font-size:13px;color:#334155;margin-top:8px}
  #finalScore{font-weight:bold;margin-top:12px}
  .pane{background:#fff;padding:12px;border-radius:8px;box-shadow:0 6px 18px rgba(11,37,69,0.06);margin-bottom:12px}
  .small{font-size:13px;color:#334155}
  .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:8px}
</style>
</head>
<body>

<h1>Simplex KKT - Quadrático Interativo</h1>

<div class="pane">
  <div class="small"><strong>Instruções rápidas</strong></div>
  <ol class="small">
    <li>Preencha Nome, n (variáveis) e m (restrições). Clique em <em>Gerar Formulário</em>.</li>
    <li>Preencha coeficientes da FO e restrições. Clique em <em>Iniciar Iterações</em>.</li>
    <li>Use o tableau anterior como referência — preencha o tableau <strong>completamente</strong> da próxima iteração e clique em <em>Verificar Iteração</em>.</li>
    <li>Várias tentativas são permitidas; somente a primeira vez que a iteração for respondida corretamente conta para a nota.</li>
    <li>Ao fim, clique em <em>Gerar PDF</em> para baixar o relatório (nota 0–100).</li>
  </ol>
  <hr />
</div>

<div class="card">
  <label>Nome do aluno: <input id="studentName" type="text" placeholder="Digite seu nome"></label>
  <div style="margin-top:10px">
    <label>n (variáveis): <input id="input_n" type="number" min="1" value="2"></label>
    <label>m (restrições): <input id="input_m" type="number" min="1" value="1"></label>
    <button id="genForm" class="ghost">Gerar Formulário</button>
  </div>

  <div id="dynamicForm" style="margin-top:12px"></div>

  <div class="note">Observação: as restrições <b>xᵢ ≥ 0</b> são implícitas.</div>
  
  <div style="margin-top:12px">
    <button id="start">Iniciar Iterações</button>
    <button id="restart" class="ghost" style="display:none">Reiniciar</button>
  </div>
</div>

<div id="iterationsArea" class="card" style="display:none"></div>
<div id="feedback" class="status" style="display:none"></div>
<div id="finalScore"></div>
<div style="margin-top:12px">
  <button id="generatePDF" style="display:none">Gerar PDF</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script>
// util
function numFrom(id,fallback=0){ const el=document.getElementById(id); if(!el) return fallback; const v=parseFloat(el.value); return Number.isFinite(v)?v:fallback; }
function fmt(x){ return (Math.abs(x)<1e-12)?'0':Number(x).toFixed(6); }

// variáveis globais
let n=2, m=1;
let varNames = [];
let base = [];
let A = [], b = [], autoIterations = [];
let currentIter = 0, score = 0;
let studentName = '';
let solvedIterations = []; // marca iterações já corretas (para não contar várias vezes)

// constrói nomes: x1..xn (originais), folgas x{n+1}..x{n+m}, y1..yn, y{n+1}..y{n+m}
function buildVarNames(n,m){
  const names=[];
  for(let i=1;i<=n;i++) names.push('x'+i);
  for(let k=1;k<=m;k++) names.push('x'+(n+k)); // folgas como x_{n+1}...
  for(let i=1;i<=n;i++) names.push('y'+i);
  for(let k=1;k<=m;k++) names.push('y'+(n+k));
  return names;
}

// GERA FORMULÁRIO DINÂMICO
function generateForm(){
  n = Math.max(1, Math.floor(numFrom('input_n',2)));
  m = Math.max(1, Math.floor(numFrom('input_m',1)));
  const container = document.getElementById('dynamicForm');
  container.innerHTML = '';

  // FO
  const foCard = document.createElement('div'); foCard.className = 'card';
  foCard.innerHTML = `<div class="small"><strong>Função objetivo (maximizar) — termos quadráticos e lineares</strong></div>`;
  const grid = document.createElement('div'); grid.className = 'grid';
  for(let i=1;i<=n;i++){
    const id = `c_x${i}sq`;
    const div = document.createElement('div');
    div.innerHTML = `<label>coef x${i}²: <input id="${id}" type="number" step="any" value="-1"></label>`;
    grid.appendChild(div);
  }
  for(let i=1;i<=n;i++){
    for(let j=i+1;j<=n;j++){
      const id = `c_x${i}x${j}`;
      const div = document.createElement('div');
      div.innerHTML = `<label>coef x${i}x${j}: <input id="${id}" type="number" step="any" value="0"></label>`;
      grid.appendChild(div);
    }
  }
  for(let i=1;i<=n;i++){
    const id = `c_x${i}`;
    const div = document.createElement('div');
    div.innerHTML = `<label>coef x${i}: <input id="${id}" type="number" step="any" value="6"></label>`;
    grid.appendChild(div);
  }
  foCard.appendChild(grid);
  container.appendChild(foCard);

  // restrições
  const restrCard = document.createElement('div'); restrCard.className = 'card';
  restrCard.innerHTML = `<div class="small"><strong>Restrições lineares (≤)</strong></div>`;
  const tbl = document.createElement('table');
  let thead = `<tr><th>Restrição</th>`;
  for(let j=1;j<=n;j++) thead += `<th>a${j}</th>`;
  thead += `<th>b</th></tr>`;
  tbl.innerHTML = thead;
  for(let k=1;k<=m;k++){
    const tr = document.createElement('tr');
    let rowHtml = `<td>r${k}</td>`;
    for(let j=1;j<=n;j++){
      rowHtml += `<td><input id="a_${k}_${j}" type="number" step="any" value="${(j===k?1: (j===1 && k===1?2:0))}"></td>`;
    }
    rowHtml += `<td><input id="b_${k}" type="number" step="any" value="${(k===1?8:0)}"></td>`;
    tr.innerHTML = rowHtml;
    tbl.appendChild(tr);
  }
  restrCard.appendChild(tbl);
  container.appendChild(restrCard);

  const note = document.createElement('div'); note.className = 'note';
  note.innerHTML = 'Observação: as restrições xᵢ ≥ 0 são implícitas.';
  container.appendChild(note);
}

// MONTA MATRIZ KKT (A,b) A PARTIR DO FORMULÁRIO DINÂMICO
function montarProblema(){
  const c_x = new Array(n+1).fill(0);
  const c_x_sq = new Array(n+1).fill(0);
  const c_cross = {};
  for(let i=1;i<=n;i++){ c_x[i] = numFrom(`c_x${i}`,0); c_x_sq[i] = numFrom(`c_x${i}sq`,0); }
  for(let i=1;i<=n;i++) for(let j=i+1;j<=n;j++) c_cross[`${i}_${j}`] = numFrom(`c_x${i}x${j}`,0);

  const a = Array.from({length: m+1}, ()=> new Array(n+1).fill(0));
  const bvec = new Array(m+1).fill(0);
  for(let k=1;k<=m;k++){
    for(let j=1;j<=n;j++) a[k][j] = numFrom(`a_${k}_${j}`,0);
    bvec[k] = numFrom(`b_${k}`,0);
  }

  varNames = buildVarNames(n,m);

  base = [];
  for(let k=1;k<=m;k++) base.push('x'+(n+k)); // folgas x_{n+1}...
  for(let i=1;i<=n;i++) base.push('y'+i);

  const rows = n + m;
  const cols = 2*(n + m);
  A = Array.from({length: rows}, ()=> new Array(cols).fill(0));
  b = new Array(rows).fill(0);

  const off_x = 0;
  const off_s = n;
  const off_y1 = n + m;
  const off_y2 = n + m + n;

  // linhas das restrições (primal)
  for(let k=1;k<=m;k++){
    const r = k-1;
    for(let j=1;j<=n;j++) A[r][off_x + (j-1)] = a[k][j];
    A[r][off_s + (k-1)] = 1;
    b[r] = bvec[k];
  }

  // linhas de estacionaridade (derivadas)
  for(let i=1;i<=n;i++){
    const r = m + (i-1);
    for(let j=1;j<=n;j++){
      if(i===j) A[r][off_x + (j-1)] = 2 * c_x_sq[i];
      else {
        const key = (i<j) ? `${i}_${j}` : `${j}_${i}`;
        A[r][off_x + (j-1)] = c_cross[key] || 0;
      }
    }
    A[r][off_y1 + (i-1)] = 1;
    for(let k=1;k<=m;k++) A[r][off_y2 + (k-1)] = -a[k][i];
    b[r] = -c_x[i];
  }

  return {A,b};
}

// salva iteração (inclui pivot info)
function saveAutoIteration(pivotInfo=null){
  autoIterations.push({ base: base.slice(), A: A.map(r=>r.slice()), b: b.slice(), pivot: pivotInfo });
}

// pivot (opera em A e b)
function pivot(row,col){
  const pv = A[row][col]; if(Math.abs(pv) < 1e-12) return;
  for(let j=0;j<A[row].length;j++) A[row][j] /= pv;
  b[row] /= pv;
  for(let i=0;i<A.length;i++){
    if(i===row) continue;
    const factor = A[i][col];
    for(let j=0;j<A[i].length;j++) A[i][j] -= factor * A[row][j];
    b[i] -= factor * b[row];
  }
  base[row] = varNames[col];
  saveAutoIteration({row: row, col: col});
}

// regra de entrada (mesma ideia: escolhe linha com b negativo)
function enteringVar(){
  let minVal = 0, row = -1;
  for(let i=0;i<b.length;i++){
    if(b[i] < minVal){ minVal = b[i]; row = i; }
  }
  if(row === -1) return null;
  const leaveVar = base[row];
  const enterVar = leaveVar.startsWith('x') ? 'y'+leaveVar.slice(1) : 'x'+leaveVar.slice(1);
  const col = varNames.indexOf(enterVar);
  return { row, col };
}

function isOptimal(){ return b.every(v => v >= -1e-9); }

// resolve automaticamente preenchendo autoIterations
function solveAutomatic(){
  montarProblema();
  autoIterations = [];
  saveAutoIteration(null); // estado inicial
  let safety = 0;
  while(!isOptimal() && safety < 200){
    const pv = enteringVar();
    if(!pv || pv.col < 0) break;
    pivot(pv.row, pv.col);
    safety++;
  }
}

// RENDER: mostra iteração anterior (read-only) e pr��xima (o aluno preenche TODO o tableau desta iteração)
function renderStudentIteration(idx){
  const area = document.getElementById('iterationsArea');
  area.style.display = 'block';
  area.innerHTML = '';

  if(autoIterations.length <= 1){
    area.innerHTML = '<div class="note">Problema já ótimo — não há iterações para preencher.</div>';
    return;
  }
  if(idx <= 0 || idx >= autoIterations.length){
    area.innerHTML = '<div class="note">Nenhuma iteração disponível para preencher.</div>';
    return;
  }

  const prev = autoIterations[idx-1];
  const curr = autoIterations[idx];

  // tabela referência (anterior)
  const tblPrev = document.createElement('table'); tblPrev.className = 'prevTable';
  tblPrev.innerHTML = `<caption>Iteração ${idx} (anterior - referência)</caption>`;
  let trh = document.createElement('tr');
  trh.innerHTML = '<th>Base</th>' + varNames.map(v=>`<th>${v}</th>`).join('') + '<th>b</th>';
  tblPrev.appendChild(trh);
  for(let r=0;r<prev.base.length;r++){
    const tr = document.createElement('tr');
    let rowHtml = `<td><input type="text" value="${prev.base[r]}" readonly></td>`;
    for(let j=0;j<varNames.length;j++) rowHtml += `<td><input type="text" value="${fmt(prev.A[r][j])}" readonly></td>`;
    rowHtml += `<td><input type="text" value="${fmt(prev.b[r])}" readonly></td>`;
    tr.innerHTML = rowHtml;
    tblPrev.appendChild(tr);
  }
  area.appendChild(tblPrev);

  // tabela atual (aluno preenche TODO o tableau)
  const tbl = document.createElement('table');
  tbl.innerHTML = `<caption>Iteração ${idx+1} (preencha todos os campos abaixo)</caption>`;
  trh = document.createElement('tr');
  trh.innerHTML = '<th>Base</th>' + varNames.map(v=>`<th>${v}</th>`).join('') + '<th>b</th>';
  tbl.appendChild(trh);
  for(let r=0;r<curr.base.length;r++){
    const tr = document.createElement('tr');
    let rowHtml = `<td><input id="iter_base_${r}" type="text" value=""></td>`;
    for(let j=0;j<varNames.length;j++){
      rowHtml += `<td><input id="iter_cell_${r}_${j}" type="text" value=""></td>`;
    }
    rowHtml += `<td><input id="iter_b_${r}" type="text" value=""></td>`;
    tr.innerHTML = rowHtml;
    tbl.appendChild(tr);
  }
  area.appendChild(tbl);

  const note = document.createElement('div'); note.className='note';
  note.innerText = `Preencha a tabela inteira para a iteração ${idx+1}. Use a iteração anterior como referência.`;
  area.appendChild(note);

  const btn = document.createElement('button'); btn.innerText = 'Verificar Iteração';
  btn.onclick = () => checkIteration(idx);
  area.appendChild(btn);

  document.getElementById('restart').style.display = 'inline-block';
}

// VERIFICAÇÃO: valida toda a iteração (toda a tabela)
function checkIteration(idx){
  if(idx <= 0 || idx >= autoIterations.length) return;
  const curr = autoIterations[idx];
  let correct = true;

  // limpa marcas visuais
  for(let r=0;r<curr.base.length;r++){
    const bEl = document.getElementById(`iter_base_${r}`);
    if(bEl) bEl.classList.remove('incorrect');
    for(let j=0;j<varNames.length;j++){
      const el = document.getElementById(`iter_cell_${r}_${j}`);
      if(el) el.classList.remove('incorrect');
    }
    const bel = document.getElementById(`iter_b_${r}`);
    if(bel) bel.classList.remove('incorrect');
  }

  // checa todas as linhas e colunas
  for(let r=0;r<curr.base.length;r++){
    const baseEl = document.getElementById(`iter_base_${r}`);
    const baseVal = (baseEl && baseEl.value) ? baseEl.value.trim() : '';
    if(baseVal !== curr.base[r]){
      if(baseEl) baseEl.classList.add('incorrect');
      correct = false;
    }
    for(let j=0;j<varNames.length;j++){
      const el = document.getElementById(`iter_cell_${r}_${j}`);
      const raw = (el && el.value) ? el.value.trim() : '';
      let val = NaN;
      if(raw.includes('/')){ const p = raw.split('/'); val = parseFloat(p[0]) / parseFloat(p[1]); }
      else val = parseFloat(raw.replace(',','.'));
      if(!Number.isFinite(val) || Math.abs(val - curr.A[r][j]) > 1e-4){
        if(el) el.classList.add('incorrect');
        correct = false;
      }
    }
    const bEl = document.getElementById(`iter_b_${r}`);
    const rawb = (bEl && bEl.value) ? bEl.value.trim() : '';
    let bv = NaN;
    if(rawb.includes('/')){ const p = rawb.split('/'); bv = parseFloat(p[0]) / parseFloat(p[1]); }
    else bv = parseFloat(rawb.replace(',','.'));
    if(!Number.isFinite(bv) || Math.abs(bv - curr.b[r]) > 1e-4){
      if(bEl) bEl.classList.add('incorrect');
      correct = false;
    }
  }

  const fb = document.getElementById('feedback'); fb.style.display = 'block';

  // se correto e ainda não resolvido antes, marca solucionado e incrementa score
  if(correct){
    if(!solvedIterations[idx]){
      solvedIterations[idx] = true;
      score++;
    }
    fb.className = 'status ok';
    fb.innerText = '✅ Iteração correta!';
    // avança
    currentIter++;
    if(currentIter < autoIterations.length){
      renderStudentIteration(currentIter);
    } else {
      const totalIterCount = Math.max(0, autoIterations.length - 1);
      const nota = totalIterCount ? Math.round(100 * score / totalIterCount) : 0;
      fb.innerText = `✅ Todas as iterações preenchidas. Nota final: ${nota}/100`;
      document.getElementById('finalScore').innerText = `Nota final: ${nota}/100`;
      document.getElementById('generatePDF').style.display = 'inline-block';
    }
  } else {
    fb.className = 'status err';
    fb.innerText = '❌ Iteração incorreta. Revise as células em vermelho. Pode tentar novamente.';
    // não contabiliza tentativa como penalidade; várias tentativas permitidas
  }
}

// EVENTOS
document.getElementById('genForm').addEventListener('click', ()=>{
  // limpa estados
  autoIterations = []; A = []; b = []; base = []; currentIter = 0; score = 0;
  solvedIterations = [];
  document.getElementById('iterationsArea').innerHTML = '';
  document.getElementById('feedback').style.display = 'none';
  document.getElementById('finalScore').innerText = '';
  document.getElementById('generatePDF').style.display = 'none';
  generateForm();
});

document.getElementById('start').addEventListener('click', ()=>{
  studentName = document.getElementById('studentName').value.trim() || 'Aluno(a) não informado(a)';
  montarProblema();
  solveAutomatic();
  // preparações para exercício
  const totalIterCount = Math.max(0, autoIterations.length - 1);
  solvedIterations = new Array(autoIterations.length).fill(false);
  score = 0;
  if(totalIterCount === 0){
    document.getElementById('iterationsArea').style.display = 'block';
    document.getElementById('iterationsArea').innerHTML = '<div class="note">Problema já ótimo — não há iterações para preencher.</div>';
    document.getElementById('generatePDF').style.display = 'inline-block';
    document.getElementById('finalScore').innerText = `Nota final: 0/100`;
    return;
  }
  currentIter = 1;
  document.getElementById('feedback').style.display = 'none';
  document.getElementById('finalScore').innerText = '';
  document.getElementById('generatePDF').style.display = 'none';
  renderStudentIteration(currentIter);
});

document.getElementById('restart').addEventListener('click', ()=>{
  autoIterations=[]; A=[]; b=[]; base=[]; currentIter=0; score=0;
  solvedIterations = [];
  document.getElementById('iterationsArea').innerHTML = '';
  document.getElementById('feedback').style.display='none';
  document.getElementById('finalScore').innerText='';
  document.getElementById('restart').style.display='none';
  document.getElementById('generatePDF').style.display='none';
});

document.getElementById('generatePDF').addEventListener('click', ()=>{
  const { jsPDF } = window.jspdf;
  const doc = new jsPDF();
  doc.setFontSize(16); doc.text('Desempenho do Aluno',20,20);
  doc.setFontSize(12); doc.text(`Nome: ${studentName}`,20,30);
  const totalIterCount = Math.max(0, autoIterations.length - 1);
  doc.text(`Total de iterações possíveis: ${totalIterCount}`,20,40);
  doc.text(`Iterações corretas: ${score}`,20,50);
  const nota = totalIterCount ? Math.round(100 * score / totalIterCount) : 0;
  doc.text(`Nota final: ${nota}/100`,20,60);
  doc.save(`${studentName.replace(/\s+/g,'_')}_SimplexKKT.pdf`);
});

// inicializa com formulário padrão
generateForm();
</script>
</body>
</html>
